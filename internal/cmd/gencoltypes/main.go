package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"strconv"
	"strings"
)

func main() {
	if err := _main(); err != nil {
		log.Println(err.Error())
		os.Exit(1)
	}
}

func _main() error {
	var buf bytes.Buffer

	types := []string{
		"Invalid",
		"Bit",
		"TinyInt",
		"SmallInt",
		"MediumInt",
		"Int",
		"Integer",
		"BigInt",
		"Real",
		"Double",
		"Float",
		"Decimal",
		"Numeric",
		"Date",
		"Time",
		"Timestamp",
		"DateTime",
		"Year",
		"Char",
		"VarChar",
		"Binary",
		"VarBinary",
		"TinyBlob",
		"Blob",
		"MediumBlob",
		"LongBlob",
		"TinyText",
		"Text",
		"MediumText",
		"LongText",
	}

	buf.WriteString(`// generated by internal/cmd/gentokens/main.go`)
	buf.WriteString("\n\npackage model")
	buf.WriteString("\n\n// ColumnType describes the possible types that a column may take")
	buf.WriteString("\ntype ColumnType int")
	buf.WriteString("\n\n// List of possible ColumnType values")
	buf.WriteString("\nconst (")
	for i, typ := range types {
		buf.WriteString("\nColumnType")
		buf.WriteString(typ)
		if i == 0 {
			buf.WriteString(" ColumnType = iota")
		}
	}
	buf.WriteString("\n\nColumnTypeMax")
	buf.WriteString("\n)")
	buf.WriteString("\n\nfunc (c ColumnType) String() string {")
	buf.WriteString("\nswitch c {")
	for _, typ := range types[1:] {
		buf.WriteString("\ncase ColumnType")
		buf.WriteString(typ)
		buf.WriteByte(':')
		buf.WriteString("\nreturn ")
		buf.WriteString(strconv.Quote(strings.ToUpper(typ)))
	}
	buf.WriteString("\ndefault:")
	buf.WriteString("\nreturn \"(invalid)\"")
	buf.WriteString("\n}")
	buf.WriteString("\n}")

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Printf("%s", buf.Bytes())
		return err
	}

	f, err := os.Create("model/columns.go")
	if err != nil {
		return err
	}
	defer f.Close()

	f.Write(formatted)
	return nil
}
